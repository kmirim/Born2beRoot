<h1 align="center" #T√≠tulo-e-Imagem-de-capa> Born2beRoot </h1>
<p align="center">
  <img loading="lazy" src="https://img.shields.io/static/v1?label=Status&message=concluded&color=7159c1&style=for-the-badge&logo=ghost"/>
</p>
<img alt="banner born2beroot" src="https://github.com/kmirim/Born2beRoot/assets/132582320/966d68c4-6002-43d1-830e-8d940d9e09df" />
<br><br><p align="center" #descri√ß√£o-do-projeto>Project to build and solidify knowledge about the Unix system and concepts such as Apparmor, SSH, UFW, etc.</p>
<br>

<h2 align="center" #index> Index </h2>

<p align="center"> ‚Ä¢ 
  <a href="#Goal">Goal</a> ‚Ä¢
  <a href="#Virtualization">Virtualization</a> ‚Ä¢ 
  <a href="#LVM">LVM</a> ‚Ä¢
  <a href="#AppArmor_UFW_SSH">AppArmor, UFW, SSH</a> ‚Ä¢ 
  <a href="#Apt_and_aptitude">Apt and aptitude</a> ‚Ä¢ 
  <a href="#Shell_Script">Shell Script</a> ‚Ä¢ 
  <a href="#Signature">Signature</a> ‚Ä¢ 
  <a href="#File_manipulation">File manipulation commands</a> ‚Ä¢
  <a href="#Vim">Vim</a> 
</p><br><br>

<h3 #Goal> ‚Ä¢ üìç Goal: </h3>
<p>The goal of this project is to teach how to set up my first server. It's not only my first experience configuring a server, but also my first experience installing a Linux operating system.</p><br>
<p> ‚ö†Ô∏è Starting from now, I will also write the notes in Portuguese to make it more accessible, considering that most of the material on the internet is in English. </p><br><br>
<h3 #Vitualization> ‚Ä¢ üñ•Ô∏è Virtualization: </h2>
<p>
  <strong>PT:</strong> Virtualiza√ß√£o <strong>√© a tecnologia que voc√™ pode usar para criar representa√ß√µes virtuais de 
servidores, armazenamento, redes e outras m√°quinas f√≠sicas</strong>.
  <strong>EN:</strong> Virtualization <strong>is the technology you can use to create virtual representations of servers, storage, networks, and other physical machines</strong>.<br><br>
</p>

<h3 #LVM> ‚Ä¢ üíΩ LVM: </h3>

Logical Volume Manager ou gerenciador de volume l√≥gico <br>

Durante o processo de instala√ß√£o do Debian (e de muitas outras distribui√ß√µes Linux), √© possivel escolher o uso do LVM para gerenciar o armazenamento do sistema. √â uma abordagem alternativa ao particionamento tradicional de discos em sistemas Linux. Em vez de criar parti√ß√µes fixas diretamente no disco, o LVM introduz uma camada l√≥gica adicional que oferece mais flexibilidade no gerenciamento do espa√ßo de armazenamento.

Como isso funciona?

LVM √© uma tecnologia que oferece uma camada de abstra√ß√£o sobre os discos f√≠sicos em um sistema Linux. Ele permite uma gest√£o mais flex√≠vel e din√¢mica do espa√ßo de armazenamento.
1. Volume Group (Grupo de Volumes): No LVM, voc√™ agrupa discos f√≠sicos em um Volume Group. Este grupo √© tratado como uma entidade √∫nica para a aloca√ß√£o de espa√ßo.
2. Logical Volume (Volume L√≥gico): Dentro do Volume Group, voc√™ cria Logical Volumes. Esses volumes s√£o an√°logos √†s parti√ß√µes em um sistema de arquivos tradicional, mas s√£o mais flex√≠veis. Eles podem ser redimensionados facilmente, o que √© uma vantagem sobre as parti√ß√µes convencionais.
3. Physical Extents (Extens√µes F√≠sicas): O espa√ßo em disco dentro de um Volume Group √© dividido em blocos chamados Physical Extents. Esses blocos s√£o a unidade m√≠nima de aloca√ß√£o.
4. File System: Um sistema de arquivos √© ent√£o criado em cima do Logical Volume, da mesma forma que voc√™ faria com uma parti√ß√£o convencional.

<br><img alt="img da estrutura do lvm" src="https://github.com/kmirim/Born2beRoot/assets/132582320/f808301d-0715-4071-b3c8-5f6f3433ad85"><br><br>

<strong>Guided - use entire disk and set up encrypted LVM: </strong> Esta op√ß√£o indica que o instalador configurar√° o LVM para gerenciar o armazenamento e, ao mesmo tempo, criptografar√° o conte√∫do do disco. A criptografia de disco √© uma camada de seguran√ßa adicional que protege os dados no disco contra acesso n√£o autorizado.

Selecionar a op√ß√£o `"Separate /home, /var, and /tmp partitions"` durante a instala√ß√£o de um sistema operacional Linux, como no Debian, refere-se √† escolha de configurar parti√ß√µes separadas para diret√≥rios espec√≠ficos do sistema, em vez de colocar todos os diret√≥rios no mesmo sistema de arquivos. Essa escolha oferece benef√≠cios em termos de organiza√ß√£o, desempenho e, em alguns casos, recupera√ß√£o de dados.

1. **Separate (/home, /var, and /tmp) partitions:**
    - **/home:** O diret√≥rio **`/home`** cont√©m os diret√≥rios pessoais dos usu√°rios. Ao separar isso em uma parti√ß√£o dedicada, os dados do usu√°rio podem ser preservados, mesmo se voc√™ precisar reinstalar o sistema operacional. Isso facilita a atualiza√ß√£o ou reinstala√ß√£o sem perder dados pessoais.
    - **/var:** O diret√≥rio **`/var`** armazena dados vari√°veis, como logs, caches e arquivos tempor√°rios. Manter isso em uma parti√ß√£o separada pode ajudar a evitar problemas de espa√ßo em disco se ocorrerem muitas grava√ß√µes frequentes de logs ou outros dados vari√°veis.
    - **/tmp:** O diret√≥rio **`/tmp`** √© usado para armazenar arquivos tempor√°rios. Ter uma parti√ß√£o separada para **`/tmp`** pode fornecer benef√≠cios de seguran√ßa e desempenho, pois os arquivos tempor√°rios podem ser configurados para ter permiss√µes restritas e podem estar em uma parti√ß√£o montada com op√ß√µes espec√≠ficas.
    
    Ao escolher essa op√ß√£o, voc√™ tem mais controle sobre o espa√ßo alocado para cada um desses diret√≥rios e pode configurar as op√ß√µes de montagem de cada parti√ß√£o de acordo com suas necessidades espec√≠ficas.
    
    Essa abordagem tamb√©m pode facilitar a manuten√ß√£o e a recupera√ß√£o de dados em determinadas situa√ß√µes, uma vez que problemas em um diret√≥rio espec√≠fico (por exemplo, falta de espa√ßo em **`/var`** ou **`/tmp`**) n√£o afetar√£o diretamente outros diret√≥rios do sistema.
    
    No entanto, essa escolha adiciona uma camada de complexidade ao gerenciamento do sistema de arquivos, ent√£o √© importante entender as necessidades do seu sistema ao fazer essa escolha.
   
  <strong> A criptografia de disco √© uma camada de seguran√ßa adicional que protege os dados no disco contra acesso n√£o autorizado. </strong><br>
‚ö†Ô∏è Comando utilizado para que possamos verificar o particionamento do disco: **`lsblk`**

<h3 #AppArmor_UFW_SSHP> ‚Ä¢ üõ°Ô∏è AppArmor, UFW, SSH: </h3>

**O que √© AppArmor?**

AppArmor √© um sistema de controle de acesso obrigat√≥rio (MAC, Mandatory Access Control), similar ao SELinux.
Possiveis motivos para optar pelo AppArmor ao inv√©s do SELinux?
**AppArmor foi projetado para ser mais simples de usar e configurar em compara√ß√£o com alguns outros sistemas MAC, como SELinux.**   
    - O AppArmor √© muitas vezes considerado mais f√°cil de configurar e usar em compara√ß√£o com o SELinux. Ele utiliza perfis de aplicativos que s√£o mais simples de compreender e implementar.
    - AppArmor adota um modelo de perfil mais simplificado em compara√ß√£o com o SELinux. Os perfis do AppArmor s√£o geralmente mais f√°ceis de criar e entender, o que pode ser uma vantagem para administradores menos familiarizados com controles de acesso obrigat√≥rio.
    - √â uma integra√ß√£o padr√£o em algumas distribui√ß√µes, como: Ubuntu.

**E como o AppArmor funciona?**

  - Seguran√ßa Baseada em Perfil:
        O AppArmor funciona com base em perfis. Cada aplicativo ou processo em execu√ß√£o no sistema tem um perfil associado que define os recursos e permiss√µes que ele pode acessar.
        Os perfis s√£o tipicamente definidos em arquivos de texto leg√≠veis por humanos e especificam regras que restringem as a√ß√µes de um programa. Essas regras definem quais arquivos, diret√≥rios e capacidades o programa tem permiss√£o para acessar.

 - Aplica√ß√£o Baseada em Caminho:
        O AppArmor usa principalmente a aplica√ß√£o baseada em caminho. Isso significa que ele se concentra em controlar o acesso a arquivos e diret√≥rios espec√≠ficos em vez de chamadas de sistema gerais.
        Quando um programa tenta acessar um arquivo, o AppArmor verifica se o acesso √© permitido de acordo com as regras definidas no perfil associado a esse programa.

 - Integra√ß√£o com Servi√ßos do Sistema:
        O AppArmor se integra a servi√ßos e aplicativos do sistema. Por exemplo, no caso do Debian, √© frequentemente usado para confinar servi√ßos como servidores web, bancos de dados ou outros processos cr√≠ticos.
        Os perfis s√£o carregados no kernel durante a inicializa√ß√£o do sistema e s√£o aplicados assim que os processos associados s√£o iniciados.

  - Aplica√ß√£o em Tempo de Execu√ß√£o:
        O AppArmor fornece aplica√ß√£o em tempo de execu√ß√£o, o que significa que as pol√≠ticas de seguran√ßa s√£o aplicadas enquanto o sistema est√° em execu√ß√£o. Isso ajuda a evitar o acesso n√£o autorizado a recursos sens√≠veis durante a opera√ß√£o do sistema.

  - Flexibilidade e Configurabilidade:
        O AppArmor permite controle granular sobre o comportamento do aplicativo. Voc√™ pode especificar quais arquivos ou diret√≥rios um aplicativo pode ler, gravar ou executar. Essa granularidade ajuda a adaptar as pol√≠ticas de seguran√ßa a casos de uso espec√≠ficos.
        Os perfis podem ser personalizados para atender aos requisitos de seguran√ßa de aplicativos individuais.

  - Auditoria e Logs:
        O AppArmor fornece recursos de auditoria que registram eventos relacionados √† seguran√ßa. Isso pode ser √∫til para monitorar e analisar o comportamento de aplicativos confinados.
        Os logs ajudam os administradores a identificar e solucionar problemas de seguran√ßa, fornecendo informa√ß√µes sobre quais recursos um aplicativo tentou acessar e se esses acessos foram permitidos ou negados.

  - Facilidade de Uso:
        O AppArmor √© projetado para ser f√°cil de usar. Ele fornece uma camada adicional de seguran√ßa sem exigir uma configura√ß√£o manual extensiva. O uso de perfis simplifica o processo de prote√ß√£o de aplicativos.

Ao confinar aplicativos a perfis de seguran√ßa bem definidos, o AppArmor aprimora a seguran√ßa geral do sistema, minimizando o impacto potencial de vulnerabilidades de seguran√ßa em aplicativos individuais. √â uma ferramenta eficaz para melhorar a postura de seguran√ßa de sistemas Linux.

‚ö†Ô∏è Comando utilizado para que possamos verificar se o servi√ßo esta ativo: **`systemctl status apparmor`**
